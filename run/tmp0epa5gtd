# -*- coding: utf-8 -*-
"""
Created on Tue Nov 24 10:34:37 2020

@author: WEIHAO
"""

# In[]:import

from prep_extension._config._config import config_set
from prep_extension.common.api import time_utc_formated
import datetime
from os.path import join
import os
import subprocess
from math import ceil


# In[]:
    
class prep_run:
    
    def __init__(self):
        
        self.config = config_set()
        self.read_config()
        self.read_custom_prep_versions()
        
        self.prep_last_verison = self.prep_last_verison()    

def run_prep_win(prepfile_folder_path, 
                 prepfile_name
                 ):
  
    # record start time
    start_time_4logname = time_utc_formated()
    start = datetime.datetime.now() 
  
    # prepare the prep path, decide run prep version
    try:
        prep_version = config.prep_files_script_version[prepfile_folder_path][prepfile_name]
        # default is to refer the file: prep_files_script_version
        print(f"{prepfile_name} is using the Defined Version: {prep_version}")
    except:
        prep_version = config.prep_last_verison
        print(f"{prepfile_name} is using the latest Version: {prep_version}, no version defined in the file")
    
    prep_path = config.prep_script_path[ prep_version ]
        
    # prepare the cmd which is sent to tableau prep script
    located_prep_bat = '"' + join(prep_path, 'tableau-prep-cli.bat') + '"'
    located_prep_file = ' -t ' + '"' + prepfile_name + '.tfl' + '"'
    
    # cmd will be depend on whether there is a credential or not.
    # check whether the credentials file exist, if yes, with it; if no, skip
    credentials_file_name = prepfile_name + config.credentials_file_suffix
    if os.path.isfile( join(prepfile_folder_path, credentials_file_name) ):
        print(f"{prepfile_name} is with credentials file")
        located_prep_credentials = ' -c ' + '"' + credentials_file_name +'"'
        cmd = located_prep_bat + located_prep_credentials + located_prep_file
    else:
        print(f"{prepfile_name} is without credentials file")
        cmd = located_prep_bat + located_prep_file
    
    # for showing
    print(cmd) 

    logs = []    
    # run prep by prep script
    process = subprocess.Popen(args = cmd,
                               shell = True,
                               stdout = subprocess.PIPE,
                               stderr = subprocess.PIPE,
                               cwd = prepfile_folder_path # cd path
                               )
    # save and showing log
    for line in process.stdout:
        logs.append(line)
        print(line)
    
    # save errcode
    errcode = process.returncode
    
    # record end time and processing time
    end = datetime.datetime.now() 
    processing_min = str( int( ceil( (end - start).total_seconds()/60))) # take ceiling min

    # save logs
    log_name = "\log_" + prepfile_name + '_' + start_time_4logname + '_' + processing_min + '.txt'
    log_path = config.log_save_path + log_name

    # write way use wb+, please refer: https://blog.csdn.net/liuweiyuxiang/article/details/78182603
    with open( log_path , "wb+") as f:
        for line in logs:
            f.write(line)
    
    # show error if have
    if errcode is not None:
        raise Exception('cmd %s failed, see above for details', cmd)
    
    return logs



# In[]:check_run_data_correct

# following parameter will control by the config file
check_file_locate_suffix = config['check_file_locate_suffix']
check_file_tag = config['check_file_tag']

import pandas as pd

def check_run_data_correct(prepfile_folder_path,
                           prepfile_name
                           # error_tag = 'ALERT-ALERT-ALERT',
                           # NoteA: rigth now, the design for outputing the error file is correct if with no data.  So, just determine whether the error file contain data or not.
                           ):
  
  # make list files folder path
  check_file_locate = join(prepfile_folder_path, prepfile_name + check_file_locate_suffix)
  # list files
  check_file_names, check_file_paths = list_files_path_in_folder(check_file_locate)
  
  error_files_name = []
  error_files_path = []
  
  for check_file_name, check_file_path in zip(check_file_names, check_file_paths):

    if check_file_tag in check_file_name:
      # if default will use c run, and meet error: 'Initializing from file failed'
      # avoid messy word, use encoding='utf-8-sig'; reason: https://stackoverflow.com/questions/25788037/pandas-df-to-csvfile-csv-encode-utf-8-still-gives-trash-characters-for-min
      check_file_content = pd.read_csv(check_file_path, engine='python', encoding='utf-8-sig')
      
      # determine the file is with error or not.  why use this way, please refer above 'NoteA'
      if check_file_content.shape[0] > 0:
        error_files_name.append(check_file_name)
        error_files_path.append(check_file_path)
        
  return error_files_name, error_files_path


# In[]:run_prep_flow_main

# following parameter will control by the config file
retry_max = config['retry_max']

def run_prep_win_main(prepfile_folder_path, 
                      prepfile_name,
                      slack_channel = 'Default'
                      ):
  
  # retry if fail
  retried_times = 0
  logs = []
  while (check_run_successful(list_name = logs) == False and 
         retried_times <= retry_max):
    
    logs = run_prep_win(prepfile_folder_path = prepfile_folder_path, 
                        prepfile_name = prepfile_name,
                        )
    
    # send meg if run prep fail
    if check_run_successful(list_name = logs) == False:
      main_msg = f"[ERROR] Tableau Prep Flow Run Failed.  Retried Times: {retried_times}"\
                 f"\n"\
                 f"{prepfile_folder_path}"
      sub_msgs_dict = {}
      sub_msgs_dict['title'] = [prepfile_name]
      sub_msgs_dict['title_link'] = [join(prepfile_folder_path,prepfile_name)]
    
      send_message_to_slack(main_msg = main_msg, 
                            sub_msgs_dict = sub_msgs_dict, 
                            color_sub_msg = 'danger')
        
    retried_times += 1
  
  # check the error file only when the prep run success   
  if retried_times != retry_max:
    # get the error files
    error_files_name, error_files_path = check_run_data_correct(
        prepfile_folder_path = prepfile_folder_path,
        prepfile_name = prepfile_name
        )
    
    # send msg only there is an error file
    if len(error_files_name) > 0: 
      # generate main msg for slack send msg
      main_msg = f"[Warning] Found Faulty Data in Tableau Prep Flow.  Flow Name: {prepfile_name}" \
                 f"\n"\
                 f"{prepfile_folder_path}"  
      
      # generate the sub_msgs for slack send msg
      sub_msgs_dict = {}
      sub_msgs_dict['title'] = error_files_name
      sub_msgs_dict['title_link'] = error_files_path
        
      # send meg by slack      
      if slack_channel == 'Default':
        send_message_to_slack(main_msg = main_msg, 
                              sub_msgs_dict = sub_msgs_dict,
                              color_sub_msg = 'warning',
                              )
      else:
        send_message_to_slack(main_msg = main_msg, 
                              sub_msgs_dict = sub_msgs_dict,
                              color_sub_msg = 'warning',
                              channel = slack_channel
                              )        
    

# In[]:run_prep_self

run_self_suffix = config['run_self_suffix']
      
def run_prep_self(prepfile_folder_path, 
                  py_file_name,
                  slack_channel = 'Default'
                  ):
   
  # generate file name
  prepfile_name = py_file_name.replace(run_self_suffix +'.py', '') # remove run_self_suffix.py
  
  # run prep
  run_prep_win_main(prepfile_folder_path = prepfile_folder_path, 
                    prepfile_name = prepfile_name, 
                    slack_channel = slack_channel
                    )

# In[]:
